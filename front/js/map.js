/*
 * Copyright (C) 2024 Vladimir Homutov
 */

/*
 * This file is part of Rieman.
 *
 * Rieman is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Rieman is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 */

import './style.css';

import olMap                                 from 'ol/Map.js';
import olOSM                                 from 'ol/source/OSM.js';
import olVectorSource                        from 'ol/source/Vector.js';
import olVectorLayer                         from 'ol/layer/Vector.js';
import olTileLayer                           from 'ol/layer/Tile.js';
import olGPX                                 from 'ol/format/GPX.js';
import olView                                from 'ol/View.js';
import olFeature                             from 'ol/Feature.js';
import olSelect                              from 'ol/interaction/Select.js';

import {click as olClick}                    from 'ol/events/condition.js';
import {getLength as olGetLength}            from 'ol/sphere.js';
import {createStringXY as olCreateStringXY}  from 'ol/coordinate.js';

import * as olExtent                         from 'ol/extent';
import * as olGeom                           from 'ol/geom.js'
import * as olProj                           from 'ol/proj.js'
import * as olStyle                          from 'ol/style.js'
import * as olCtl                            from 'ol/control.js';


/* generated by: https://medialab.github.io/iwanthue/ */
const palette = ["#ffc75a", "#341b88", "#a9e569", "#011f7d", "#47c158",
                 "#3b42b3", "#9a9800", "#430065", "#6aeca8", "#8a0070",
                 "#007203", "#ca67d9", "#005e18", "#dc4db0", "#00ebe5",
                 "#b71d23", "#00b9e6", "#cb670b", "#6a99ff", "#fba638",
                 "#003690", "#d6da7e", "#342560", "#ff8d44", "#0169ad",
                 "#ff8a60", "#018250", "#ff61b2", "#5b6900", "#d092ff",
                 "#7f6900", "#ffa2f6", "#754100", "#ffa9df", "#822800",
                 "#512f6b", "#ffc182", "#6c003d", "#b3a057", "#8f5b98",
                 "#77000b", "#ff7da1", "#78002e", "#ff9b80", "#960030",
                 "#ff7f7e", "#ac0030", "#c56a65", "#ff6683", "#ff6d73"];

let lang = 'ru';

const lang_db = {
    en: {
        km: 'km',
        kmph: 'km/h',
        speed: 'Speed',
        distance_made: 'Distance made',
        tracking_distance: 'Tracking distance',
        tracking_time: 'Tracking time',
        route_status: 'Route status',
        route_position: 'Route position',
        lost: 'lost',
        on_track: 'on track',
        off_track: 'off',
        ride_status: 'Ride status',
        position_updated: 'Position updated',
        ago: 'ago',
        now: 'now',
        status_moving:'Moving',
        status_pitstop:'Pit-Stop',
        status_puncture:'The Puncture',
        status_fall:'The fall',
        status_incident:'Road Incident',
        status_finished:'Finished',
        status_dnf:'Cancelled',
        unavail: 'n/a',
        html_title: 'VCC MOGT live map',
        html_clmarker_hint: 'Marker color',
        html_clmarker_name: 'C',
        html_rank_hint: 'Track Rank',
        html_rank_name: 'R',
        html_username_hint: 'Telegram username',
        html_username_name: 'Name',
        html_status_hint: 'Status',
        html_status_name: 'S',
        html_distance_hint: 'Distance on track',
        html_distance_name: 'Distance',
    },
    ru: {
        km: 'км',
        kmph: 'км/ч',
        speed: 'Скорость',
        distance_made: 'Пройденная дистанция',
        tracking_distance: 'Отслеженная дистанция',
        tracking_time: 'Время отслеживания',
        route_status: 'Статус маршрута',
        route_position: 'Позиция на маршруте',
        lost: 'утерян',
        on_track: 'на трассе',
        off_track: 'отклонение',
        ride_status: 'Статус поездки',
        position_updated: 'Позиция обновлена',
        ago: 'тому назад',
        now: 'сейчас',
        status_moving:'Движение',
        status_pitstop:'Остановка',
        status_puncture:'Прокол',
        status_fall:'Падение',
        status_incident:'ДТП',
        status_finished:'Финишировал',
        status_dnf:'Прекращена',
        unavail: 'н/д',
        html_title: 'Интерактивная карта VCC MOGT',
        html_clmarker_hint: 'Цвет маркера',
        html_clmarker_name: 'Ц',
        html_rank_hint: 'Позиция на трассе',
        html_rank_name: 'П',
        html_username_hint: 'Имя в Telegram',
        html_username_name: 'Имя',
        html_status_hint: 'Состояние',
        html_status_name: 'С',
        html_distance_hint: 'Дистанция по трассе',
        html_distance_name: 'Дистанция',
    }
}

let i18n = lang_db[lang];

/*
 * Map layers:
 *
 *  OSM          - tile background with OSM maps
 *  gpx_layer    - track from GPX
 *  people_layer - positions of people received from bot
 */

const debug = 0
const track_depth = 64
const max_offtrack = 2000

let people = new Map();       /* userinfo */

let map = null                /* OpenLayers map */
let gpx_layer = null
let people_layer = null
let route_layer = null
let selectClick = null;       /* to trigger select events */

let selected_feature = null   /* selected user */

let show_labels = false

let route = new Object()
route.segments = []
route.length = 0
route.start = null
route.end = null


const figures = {
    'triangle': {
        points: 3,
        angle: 0,
        rotation: 0,
    },
    'square': {
        points: 4,
        angle: Math.PI / 4,
    },
    'star': {
        points: 5,
        radius: 10,
        radius2: 4,
        angle: 0,
    },
}

const styles = {
    /* GPX Track */
    multiline: {
        stroke: { color: 'Navy', width: 3, },
    },

    marker: {
        label: {
            scale:    1.5,
            offsetX:  6,
            offsetY:  6,
            textAlign:    'left',
            textBaseline: 'top',
            padding: [ 1, 2, 1, 2 ],

            fill:             { color: 'Black' }, /* text itself */
            backgroundStroke: { color: 'Black' }, /* border */
            backgroundFill:   { color: 'White' }, /* text background */
        },
        circle: {
            fill:   { color: 'Black', }, /* stub, auto-assigned */
            stroke: { color: 'Black', width: 1 },
            radius: 5,
        },

        /* person track path */
        stroke: { color: 'Black', width: 5 },
    },

    route_mark_start: {
        label: {
            textAlign:    'left',
            textBaseline: 'bottom',
            offsetX:  -40,
            offsetY:  -10,
            padding: [ 1, 2, 1, 2 ],
            font: 'small-caps bold 14px sans-serif',
            fill:             { color: 'Yellow' },  /* text itself */
            backgroundStroke: { color: 'Yellow' },  /* border */
            backgroundFill:   { color: 'Green' },   /* text background */
        },
        shape: {
            rotateWithView: true,
            figure: figures['triangle'],
            stroke: { color: 'Yellow' },
            fill:   { color: 'Green'  },
            radius: 10,
        }
    },

    route_mark_end: {
        label: {
            textAlign:    'left',
            textBaseline: 'top',
            offsetX:  6,
            offsetY:  6,
            padding: [ 1, 2, 1, 2 ],
            font: 'small-caps bold 14px sans-serif',
            fill:             { color: 'Yellow' }, /* text itself */
            backgroundStroke: { color: 'Yellow' }, /* border */
            backgroundFill:   { color: 'Sienna' }, /* text background */
        },
        shape: {
            rotateWithView: true,
            figure: figures['square'],
            stroke: { color: 'Yellow' },
            fill:   { color: 'Sienna' },
            radius: 9,
        }
    },

    route_mark_mile: {
        label: {
            textAlign:    'left',
            textBaseline: 'top',
            offsetX:  0,
            offsetY:  10,
            padding: [ 1, 2, 1, 2 ],
            font: 'small-caps 12px sans-serif',
            fill:             { color: 'Black' }, /* text itself */
            backgroundStroke: { color: 'LightGreen' }, /* border */
            backgroundFill:   { color: 'LightGreen' }, /* text background */
        },
        shape: {
            rotateWithView: true,
            figure: figures['triangle'],
            fill:   { color: 'LightGreen'},
            stroke: { color: 'DarkGreen', width: 2 },
            radius: 10,
            scale:  [ 0.6, 1 ],
        }
    },
}


function init_map()
{
    const tiles_layer = new olTileLayer({source: new olOSM()})

    const gpx_source_conf = {
        url: './assets/track.gpx',
        format: new olGPX(),
    }

    const gpx_vector = {
        source: new olVectorSource(gpx_source_conf),
        style: apply_style,
    }

    gpx_layer = new olVectorLayer(gpx_vector);

    /* set function to call when source loads */
    gpx_layer.getSource().on('addfeature', fit_layer);

    const mousePositionControl = new olCtl.MousePosition(mousePositionConf);

    const rotation = new olCtl.Rotate({
        rotateOptions: { autoHide: false }
    });


    const view_conf = {
        center: [0, 0],
        zoom: 2,
    }

    const controls_list = [
        scaleControl(),
        mousePositionControl,
        rotation,
        new UserLabelControl(),
        new LangControl(),
    ];

    const select_config = {
        condition: olClick,
        style:     set_marker_selected,
        filter:    select_markers_filter,
    }

    selectClick = new olSelect(select_config);


    let selectedFeatures = selectClick.getFeatures();
    selectedFeatures.on('add', on_feature_selected);
    selectedFeatures.on('remove', on_feature_deselected);

    const people_layer_config = {
        source: new olVectorSource(),
        style: set_text_from_property,
        /* declutter: true, */  /* not nice: markers disapperar with text */
    }

    people_layer = new olVectorLayer(people_layer_config);

     const route_layer_config = {
        source: new olVectorSource(),
        style:     set_route_mark_style,
    }

    route_layer = new olVectorLayer(route_layer_config);

    const map_conf = {
        target: 'map',
        layers: [ tiles_layer, gpx_layer, route_layer, people_layer ],
        view: new olView(view_conf),
        controls: olCtl.defaults().extend(controls_list),
    }


    map = new olMap(map_conf);

    /* open the view to force a load */
    map.getView().setCenter([0, 0]);
    map.getView().setZoom(0);

    map.addInteraction(selectClick);
}


class UserLabelControl extends olCtl.Control {
    constructor(opt_options) {

        const button = document.createElement('button');
        button.innerHTML = '🚩';

        const element = document.createElement('div');

        const cont = document.getElementById('ctl');

        element.className = 'userlabel-switch ol-unselectable ol-control';
        element.appendChild(button);

        super({
            element: element,
            target: cont,
        });

        button.addEventListener('click', this.toggleUserLabel.bind(this), false);
    }

    toggleUserLabel() {

        if (show_labels == true) {
            show_labels = false;

        } else {
            show_labels = true;
        }

        update_gui()
    }
}

class LangControl extends olCtl.Control {
    constructor(opt_options) {

        const button = document.createElement('button');
        button.innerHTML = '🌐';

        const element = document.createElement('div');

        const cont = document.getElementById('ctl');

        element.className = 'lang-switch ol-unselectable ol-control';
        element.appendChild(button);

        super({
            element: element,
            target: cont,
        });

        button.addEventListener('click', this.toggleLang.bind(this), false);
    }

    toggleLang() {

        if (lang == 'ru') {
            lang = 'en';

        } else {
            lang = 'ru';
        }

        i18n = lang_db[lang];

        init_html()
        update_gui()
    }
}



function toggleVisible(x)
{
    if (x.style.display === "none") {
        x.style.display = "block";
    } else {
        x.style.display = "none";
    }
}


function palette_color(index)
{
    let ncolors = palette.length

    return palette[index % ncolors]
}


function start_events()
{
    let eSource = new EventSource("/people");
    eSource.addEventListener("posupdate", source_event_handler);

    let getJSON = function(url, callback) {
        let xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.responseType = 'json';

        xhr.onload = function() {
            let status = xhr.status;

            if (status === 200) {
              callback(null, xhr.response);

            } else {
              callback(status, xhr.response);
            }
        };
        xhr.send();
    };

    getJSON('/bootstrap', function(err, data) {
        if (err !== null) {
            console.log("oops")
            return
        }

        for (let i = 0; i < data.length; i++) {
            const u = data[i]
            const key = u['UserName']

            if (debug != 0) {
                console.log('boostrap data:', u)
            }

            let person = person_from_update(u)
            people.set(key, person)

            mark_new_person(person)
        }

        update_gui()
    });

}


function print_r(msg, obj) {
    console.log(msg, JSON.stringify(obj, null, 2));
}


function createLabel(conf)
{
    let sc = init_style_conf(conf)
    return new olStyle.Text(sc)
}

function createCircle(conf)
{
    let sc = init_style_conf(conf)
    return new olStyle.Circle(sc)
}


function createShape(conf) {

    let sc = structuredClone(conf['figure']);

    Object.keys(conf).forEach(function(key) {
        if (key == 'figure') {
            return
        }

        sc[key] = conf[key]
    });

    let spec = init_style_conf(sc)

    return new olStyle.RegularShape(spec)
}

function init_style_conf(conf)
{
    let sc = structuredClone(conf);

    const handlers = {
        fill:             { obj: olStyle.Fill },
        backgroundFill:   { obj: olStyle.Fill },
        stroke:           { obj: olStyle.Stroke },
        backgroundStroke: { obj: olStyle.Stroke },

        label:            { dst: 'text',  obj: createLabel },
        circle:           { dst: 'image', obj: createCircle },
        shape:            { dst: 'image', obj: createShape },
    }

    Object.keys(handlers).forEach(function(key) {
        if (key in conf) {
            const obj = handlers[key].obj
            const dst = handlers[key].dst || key

            sc[dst] = new obj(conf[key])
        }
    });

    return sc
}


function create_style(style_conf)
{
    return new olStyle.Style(init_style_conf(style_conf))
}

const map_styles = {
    MultiLineString: create_style(styles['multiline']),
}


function create_marker_style(feature)
{
    let msg = feature.get('text')
    let key = feature.get('key')

    /* track featyre uses 'pkey' to avoid interaction with real markers */
    let pkey = feature.get('pkey')
    if (pkey != undefined) {
        key = pkey
    }

    const style_conf = structuredClone(styles['marker']);

    style_conf['label']['text'] = msg

    let out = []

    let person = people.get(key)

    if (person) {
        let icolor = palette_color(person.index)

        if (person.selected) {
            style_conf['circle']['fill']['color'] = 'Black'
            style_conf['circle']['stroke']['width'] = 7
            style_conf['circle']['stroke']['color'] = 'Black'

            /* create bottom style */
            style_conf['stroke']['width'] = 4
            style_conf['stroke']['color'] = 'Black'
            out.push(create_style(style_conf))

            /* this goes on top of first */
            style_conf['stroke']['color'] = icolor
            style_conf['stroke']['width'] = 2

            style_conf['circle']['stroke']['width'] = 5
            style_conf['circle']['stroke']['color'] = icolor

        } else {
            style_conf['circle']['fill']['color'] = icolor
            style_conf['circle']['stroke']['width'] = 1
            style_conf['circle']['stroke']['color'] = 'Black'
        }
    }

    out.push(create_style(style_conf))

    return out
}

function apply_style(feature)
{
    return map_styles[feature.getGeometry().getType()];
}


/* --- [ Helper functions ] ------------------------------------------------ */

function create_marker(coords)
{
    return new olFeature(
        {
            geometry: new olGeom.Point(olProj.fromLonLat(coords)),
            text: ""  /* property - placeholder for label */,
            is_marker: true,
            key: "",
        }
    )
}

function getPointCoords(pos) {
    return olProj.transform([pos[0], pos[1]], 'EPSG:4326', 'EPSG:3857')
}


function create_feature_layer(features)
{
    const src = new olVectorSource()
    src.addFeatures(features)

    return new olVectorLayer({source: src});
}

function nice_round(val)
{
    return Math.round(val * 100) / 100
}

function fmt_len(length)
{
    let output;

    if (!length) {
        return ''
    }

    if (length > 100) {
        output = nice_round(length / 1000) + ' ' + i18n['km'];

    } else {
        output = nice_round(length) + ' ' + 'm';
    }

    return output
}


function get_length(coords1, coords2)
{
    return olGetLength(new olGeom.LineString([coords1, coords2]))
}


function fit_layer()
{
    const gpx_extent = gpx_layer.getSource().getExtent()

    map.getView().fit(gpx_extent);


    const zoomToExtControl = new olCtl.ZoomToExtent(
        { extent: gpx_extent,
          label: ' ✥' /* FOUR CLUB-SPOKED ASTERISK' (U+2725) */
        }
    );

    map.addControl(zoomToExtControl);

    let gpx_features = gpx_layer.getSource().getFeatures();

    gpx_features.forEach(function(feature) {

        var featureCoords = feature.getGeometry().getCoordinates();

        featureCoords.forEach(function(sectionCoords) {

            let offset = 0
            let step = 0
            let step_size = 10000 /* meters */
            let nstep = 1

            route.start = sectionCoords[0]
            route.end = sectionCoords[sectionCoords.length - 1]

            for (let i = 0; i < sectionCoords.length - 1; i++) {

                let segment = []

                let s = sectionCoords[i]
                let e = sectionCoords[i+1]

                let sc = [ s[0], s[1] ]
                let ec = [ e[0], e[1] ]

                segment['index'] = i
                segment['coords'] = [ sc, ec ]
                segment['offset'] = offset

                let line = new olGeom.LineString([sc, ec]);
                let len = olGetLength(line)

                if (i == 0) {
                    route_mark(route.start, "Start", "route_mark_start", sc, ec)
                }

                if (step + len > step_size) {
                    let fraction = (step_size - step) / len
                    let p = line.getCoordinateAt(fraction)

                    let km = (step_size * nstep / 1000) + ''

                    route_mark(p, km, "route_mark_mile", sc, ec)
                    step = len
                    nstep += 1
                }

                step += len
                offset += len

                route.segments.push(segment)
            }

            route.length = offset
        });
    });

    route_mark(route.end, "Finish", "route_mark_end", null, null)

    update_gui()

    console.log('Route LEN=', fmt_len(route.length));
}


/* --- [ People ] ---------------------------------------------------------- */

function li_head(symbol, color)
{
    return '<span style="color:'
           + color
           + ';padding:2px; padding-right:4px;">'
           + symbol
           + '</span>';
}

function shorten(str, n)
{
    if (str.length <= n) {
        return str;
    }
    const subString = str.slice(0, n-1);

    return subString.slice(0, subString.lastIndexOf(" "))
}

function calc_person_average_speed_on_track(person)
{
    let track_len = 0
    let track_time = 0

    let prev = getPointCoords(person.pos)
    let prev_time = person.last

    for (let i = 0; i < person.track.length; i++) {
        let curr = getPointCoords(person.track[i].pos)
        let curr_time = person.track[i].last

        track_len += get_length(prev, curr)

        let ds = new Date(curr_time)
        let de = new Date(prev_time)

        let delta = Math.abs(de.getTime() - ds.getTime())/1000;

        track_time += delta

        prev = curr
        prev_time = curr_time
    }

    let speed = 0

    if (track_time) {
        speed = (track_len / track_time ) * 3.6
    }

    return { 'speed': speed, 'track': track_len, 'time': track_time }
}

function person_debug(k, v)
{
    let hide = ['marker', 'track_line', 'panel'];

    if (k == 'track') {
        return v.length
    }

    for (let i = 0; i < hide.length; i++) {
        if (k == hide[i]) {
            return undefined
        }
    }

    return v
}

function panel_expand(person)
{
    let dt = new Date(person.last)
    let now = new Date(Date.now())

    let delta = Math.abs(now.getTime() - dt.getTime())/1000;

    let ago_seconds = Math.floor(delta)
    let ago
    if (ago_seconds > 0) {
        ago = '~ ' + forHumans(ago_seconds) + ' ' + i18n['ago']
    } else {
        ago = i18n['now']
    }

    let last_seen = ''

    if (now.getDate() != dt.getDate()) {
        const mname = dt.toLocaleString('default', { month: 'long' });
        last_seen += ' ' + mname + ',' + dt.getDate()

    } else {
        last_seen = fmtime(dt.getHours()) + ':' + fmtime(dt.getMinutes())
    }

    let si = calc_person_average_speed_on_track(person)

    let diverge = ''

    diverge += i18n['distance_made'] + ': ' + fmt_len(person.distance_tracked) + '<br/>'
    diverge += '<HR>'
    diverge += i18n['tracking_distance'] + ': ' + fmt_len(si.track) + '<br/>'
    diverge += i18n['tracking_time'] + ': ' + forHumans(si.time) + '<br/>'
    if (si.speed) {
        diverge += i18n['speed'] + ': ' + nice_round(si.speed) + ' '+ i18n['kmph'] +'<br/>'
    }
    diverge += '<HR>'

    diverge += i18n['route_status'] + ': '

    if (person.route_diverge && person.route_diverge > max_offtrack) {
        diverge += i18n['lost']
        diverge += ' - ' + fmt_len(person.route_diverge) + ' '+ i18n['off_track']

    } else {
        diverge += i18n['on_track'] + ' <br/>'
        diverge += i18n['route_position'] + ': ' + fmt_len(person.route_position)
        if (route.length) {
            let percent = Math.round((person.route_position / route.length) * 100)
            diverge += ' (' + percent + '%)'
        }
    }

    let ms = moving_state_to_text(person)

    if (ms.length) {
        diverge += '<br/>'+ i18n['ride_status']+': <i>' + ms + '</i>'
    }

    let debugmsg = ''
    if (debug != 0) {
        debugmsg += '<br/><pre>'
        debugmsg += JSON.stringify(person, person_debug, 2);
        debugmsg += '</pre><br/>'
    }

    return '<div>' + '<b>' + person.name + '</b>' + '<br/>'
                   + i18n['position_updated'] + ': ' + last_seen +'<br/>' + ago + '<br/><hr/>'
                   + diverge + '<br/>'
                   + '<p><i>' + person.Status + '</i></p>'
                   + debugmsg
           + '</div>';
}

function moving_state_visible(person)
{
    if (person.MovingState == 'status_puncture') {
        return true

    } else if (person.MovingState == 'status_fall') {
        return true

    } else if (person.MovingState == 'status_incident') {
        return true
    }

    return false
}

function moving_state_to_icon(person)
{
    if (person.MovingState == 'status_moving') {
        return '🚴'
    } else if (person.MovingState == 'status_pitstop') {
        return '🛏'
    } else if (person.MovingState == 'status_puncture') {
        return '⛽'
    } else if (person.MovingState == 'status_fall') {
        return '🚑'
    } else if (person.MovingState == 'status_incident') {
        return '💥'
    } else if (person.MovingState == 'status_finished') {
        return '🏁'
    } else if (person.MovingState == 'status_dnf') {
        return '⏻'
    } else {
        return ''
    }
}

function moving_state_to_text(person)
{
    if (person.MovingState.length == 0) {
        return ''
    }
    return i18n[person.MovingState]
}


function panel_set_person_title(person)
{
    const rank = person.panel.getAttribute('rank')
    const color = palette_color(person.index)

    let cells = create_person_stats_row(person)

    let td1 = cells[0]
    let td2 = cells[1]
    let td3 = cells[2]
    let td4 = cells[3]
    let td5 = cells[4]

    td1.innerHTML = li_head('■', color)
    td2.innerHTML = rank

    if (person.selected) {
        td3.innerHTML = panel_expand(person)

    } else {
        td3.innerHTML = shorten(person.name, 10)
    }

    let st

    if (person.route_diverge) {
        if (person.route_diverge < max_offtrack) {
            st = '✔ '
        } else {
            st = '⛐ '
        }
    } else {
        st = '✔ '
    }

    st += moving_state_to_icon(person)

    if (person.selected) {
        person.panel.scrollIntoView(
            {
                behavior: 'smooth',
                block: 'center'
            }
        )
    } else {
       td4.innerHTML = st

       if (person.route_diverge && person.route_diverge >= max_offtrack) {
           td5.innerHTML = i18n['unavail']

       } else {
           td5.innerHTML = fmt_len(person.route_position)
       }
    }

    person.panel.replaceChildren(...cells)
}


function update_marker(person, is_selected)
{
    const coords = getPointCoords(person.pos)

    person.marker.getGeometry().setCoordinates(coords);

    /* is_selected is valid only for real deselection events */
    if (is_selected != undefined && person.selected != is_selected) {

        if (is_selected) {

            var mapExtent = map.getView().calculateExtent(map.getSize());
            var ext = person.marker.getGeometry().getExtent();

            if (!olExtent.containsExtent(mapExtent, ext)) {
                map.getView().setCenter(coords);
            }

        }

        person.selected = is_selected
    }

    draw_trail_markers(person)

    let icon = moving_state_to_icon(person)
    let text = ''

    if (person.selected) {
        text = person.name

    } else if (show_labels) {
        text = shorten(person.name, 10)

    } else if (moving_state_visible(person)) {
        text = shorten(person.name, 10)

    } else {
        text = ''
    }

    if (text != '' && icon != '') {
        text = icon + ' ' + text
    }

    person.marker.set("text", text)

    panel_set_person_title(person)
}


function update_gui()
{
    /* calculate route positions */
    people.forEach(function(person, key, map) {
        update_person_route_position(person)

        if (person.route_diverge && person.route_diverge > max_offtrack) {
            person.panel.setAttribute('distance', 0)

        } else {
            person.panel.setAttribute('distance', person.route_position)
        }
    });

    /* sort by distance and calculate ranks */
    sort_users_panel()

    /* update markers to show proper values */
    people.forEach(function(person, key, map) {
        update_marker(person)
    });
}


function set_text_from_property(feature)
{
    return create_marker_style(feature)
}


/* --- [ Controls ] -------------------------------------------------------- */

function scaleControl()
{
    const scale_conf = {
        units: "metric",
        bar: true,
        steps: 4,
        text: false,
        minWidth: 140
    }

    return new olCtl.ScaleLine(scale_conf);
}

const mousePositionConf = {
    coordinateFormat: olCreateStringXY(4),
    projection: 'EPSG:4326'
};


function set_route_mark_style(feature)
{
    let sc = structuredClone(styles[feature.get('marker_style')])

    let rotation = feature.get('rotation')

    sc['label']['text'] = feature.get('text')
    if (rotation) {
        sc['shape']['rotation'] = -rotation + Math.PI/2
    }

    return create_style(sc)
}


function set_marker_selected(feature)
{
    let st = create_marker_style(feature);

    // st.getImage().getFill().setColor('blue');

    return st;
}


function select_markers_filter(feature, layer)
{
    if (feature.get('is_marker') == true) {
        return true;

    } else {
        return false
    }
}

function time_i18n(unit, value)
{
    if (lang == 'en') {
        return unit
    }

    if (lang != 'ru') {
        return unit
    }

    let ru = {
        years:   [ 'год', 'года', 'лет' ],
        days:    [ 'день', 'дня', 'дней' ],
        hours:   [ 'час', 'часа', 'часов' ],
        minutes: [ 'минута', 'минуты', 'минут' ],
        seconds: [ 'секунда', 'секунды', 'секунд' ],
    }

    let ru_units = ru[unit]

    if (value > 10 && value < 20) {
        return ru_units[2];
    }

    let last = Math.ceil(value) % 10

    if (last == 1) {
        return ru_units[0]
    }

    if (last >=2 && last < 5) {
        return ru_units[1]
    }

    return ru_units[2]
}


function forHumans (seconds) {

    var numyears = Math.floor(seconds / 31536000);
    var numdays = Math.floor((seconds % 31536000) / 86400);
    var numhours = Math.floor(((seconds % 31536000) % 86400) / 3600);
    var numminutes = Math.floor((((seconds % 31536000) % 86400) % 3600) / 60);
    var numseconds = (((seconds % 31536000) % 86400) % 3600) % 60;

    let   out = [ numyears, numdays, numhours, numminutes, numseconds ];
    let names = [ "years",  "days",  "hours",  "minutes",  "seconds" ];

    let outs = []

    for (let i = 0; i < out.length; i++) {
        if (out[i] != 0) {
            outs[i] = Math.ceil(out[i]) + ' ' + time_i18n(names[i], out[i])
        }
    }

    return outs.join(' ')
}

function fmtime(n)
{
    return String(n).padStart(2, 0);
}


function draw_trail_markers(person)
{
    if (person.selected) {
        draw_trail_lines(person)

    } else {
        remove_trail_lines(person)
    }
}


function draw_trail_lines(person)
{
    const layer = people_layer.getSource()

    if (person.track_line.length) {
        remove_trail_lines(person)
    }

    let segments = []
    let prev

    for (let i = 0; i < person.track.length; i++) {
        let curr = getPointCoords(person.track[i].pos)

        if (i == 0) {
            prev = curr
            continue
        }

        segments.push([prev, curr])
        prev = curr
    }

    if (segments.length) {
        let last = getPointCoords(person.pos)
        segments.push([prev, last])
    }

    for (let i = 0; i < segments.length; i++) {
        let s = segments[i]

        const ftrack = new olFeature({ geometry: new olGeom.LineString(s) });
        ftrack.set("pkey", person.name)

        person.track_line.push(ftrack)
        layer.addFeature(ftrack);
    }
}

function remove_trail_lines(person)
{
    const layer = people_layer.getSource()

    for (let i = 0; i < person.track_line.length; i++) {
        let ftrack = person.track_line[i]
        layer.removeFeature(ftrack)
    }

    person.track_line.length = 0
}


function update_person_route_position(person)
{
    const coords = getPointCoords(person.pos)

    /* do not calculate route position again if coordinates did not change */
    if (person.last_route_position == person.pos) {
        return
    }

    let f = gpx_layer.getSource().getClosestFeatureToCoordinate(coords)
    if (f) {
        let p = f.getGeometry().getClosestPoint(coords)
        if (p) {
            //draw_debug_point(p, "HERE")
            person.route_position = route_position(p)
            person.last_route_position = person.pos

            /* calculate distance to track */
            let a = [ p[0], p[1] ]

            person.route_diverge = get_length(a, coords)

        } else {
            person.route_position = null
            person.route_diverge = null
        }
    } else {
        person.route_position = null
        person.route_diverge = null
    }
}

function route_position(p)
{
    let min_idx = null
    let min = null

    for (let i = 0; i < route.segments.length; i++) {
        let seg = route.segments[i]

        let a = [ p[0], p[1] ]
        let b = seg['coords'][0]

        let len = get_length(a, b)

        if (min == null) {
            min_idx = i
            min = len
            continue
        }

        if (len < min) {
            min = len
            min_idx = i
        }
    }

    let ms = route.segments[min_idx]

    return ms.offset + min
}


function on_feature_selected(evt)
{
    if (selected_feature != null) {
        on_feature_deselected(evt);
    }

    let feature = evt.target.item(0);
    let key = feature.get("key")

    if (key == "") {
        /* clicked on track marker */
        return
    }

    selected_feature = feature
    update_marker(people.get(key), true)
}


function on_feature_deselected(evt)
{
    let feature = evt.target.item(0);
    if (!feature) {
        feature = selected_feature;
        if (!feature) {
            return
        }
    }

    let key = feature.get("key")
    if (key == "") {
        /* clicked on track marker */
        return
    }

    selected_feature = null
    update_marker(people.get(key), false)
}


function route_mark(coords, txt, style, start, end)
{
    let rotation = 0

    if (start != null) {
        const dx = end[0] - start[0];
        const dy = end[1] - start[1];
        rotation = Math.atan2(dy, dx);
    }


    const mark_conf = {
        geometry: new olGeom.Point(coords),
        marker_style: style,
        text: txt,
    }

    let mark = new olFeature(mark_conf)
    mark.set('rotation', rotation)

    route_layer.getSource().addFeature(mark)
}


function draw_debug_point(point, txt)
{
    let pp = new olFeature(
        {
            geometry: new olGeom.Point(point),
            text: txt,
            is_marker: false,
            key: "",
        }
    )

    people_layer.getSource().addFeature(pp)
}

function mark_new_person(person)
{
    let marker = create_marker(person.pos);

    if (show_labels) {
        marker.set("text", shorten(person.name, 10))
    }

    marker.set("key", person.name)
    person.marker = marker
    people_layer.getSource().addFeature(marker)

    person.panel = create_user_entry_on_panel(person)
    add_user_to_panel(person)
}


function person_from_update(u)
{
    let person = new Object();

    person.index = people.size
    person.name = u['UserName']
    person.pos = [ u["Pos"]["Lon"], u["Pos"]["Lat"] ]
    person.Status = u["Status"]
    person.MovingState = u["MovingState"]
    person.last = u["Last"]
    person.distance_tracked = 0
    person.track_line = []
    update_person_route_position(person);
    person.last_route_position = null
    person.route_diverge = null
    person.selected = false

    person.track = new Array()

    if (u["Track"]) {
        const ut = u["Track"]

        for (let i = 0; i < ut.length; i++) {
            let p = new Object()
            const pos = ut[i]

            p.pos = [pos["Lon"], pos["Lat"]]
            p.last = u["Last"]
            p.marker = create_marker(p.pos)
            person.track.push(p)
        }
    }

    if (debug != 0) {
        console.log("created new person " + person.name)
    }

    return person
}


function person_click_on_panel(key)
{
    let person = people.get(key);

    /* simulate feature selection */

    selectClick.getFeatures().clear()
    selectClick.getFeatures().push(person.marker);
    selectClick.dispatchEvent({
        type: 'select',
        selected:   [ person.marker ],
        deselected: []
    });
}

function create_person_stats_row(person)
{
    let cells = []

    let td1 = document.createElement('td')
    td1.setAttribute('class', 'colormark')
    cells.push(td1)

    let td2 = document.createElement('td')
    td2.setAttribute('class', 'rank')
    cells.push(td2)

    let td3 = document.createElement('td')
    td3.setAttribute('class', 'name')

    td3.addEventListener('click', function() {
        person_click_on_panel(person.name);
    }, false)

    cells.push(td3)

    if (person.selected) {
        td3.setAttribute('colspan', '3')
        return cells
    }

    let td4 = document.createElement('td')
    td4.setAttribute('class', 'unread')
    cells.push(td4)

    let td5 = document.createElement('td')
    td5.setAttribute('class', 'routepos')
    cells.push(td5)

    return cells
}

function create_user_entry_on_panel(person)
{
    let item = document.createElement('tr')
    item.id = person.name
    item.setAttribute('distance', 0)

    let cells = create_person_stats_row(person)

    item.replaceChildren(...cells)

    return item
}


function add_user_to_panel(person)
{
    const userlist = document.getElementById('userlist_body');
    userlist.appendChild(person.panel)
}


function sort_users_panel()
{
    const ul = document.getElementById('userlist_body');

    let new_ul = ul.cloneNode(false);

    let lis = [];
    for (let i = ul.childNodes.length; i--;) {
        if (ul.childNodes[i].nodeName === 'TR')
            lis.push(ul.childNodes[i]);
    }

    lis.sort(function(a, b) {

        let av = a.getAttribute('distance')
        let bv = b.getAttribute('distance')

        if (av == bv || av == null || bv == null || av == '' || bv == '') {
            av = a.id
            bv = b.id

        } else {
            av = Number(av)
            bv = Number(bv)
        }

        if (bv < av) {
            return -1;
        } else if (bv > av) {
            return 1;
        } else {
            return 0;
        }
    });

    for (let i = 0; i < lis.length; i++) {
        lis[i].setAttribute('rank', i + 1)
        new_ul.appendChild(lis[i]);
    }

    ul.parentNode.replaceChild(new_ul, ul);
}


function source_event_handler(event)
{
    const updates = JSON.parse(event.data);

    if (updates['Alive'] == true) {
        console.log('keepalive')
        return
    }

    for (let i = 0; i < updates.length; i++) {
        const u = updates[i]

        if (debug != 0) {
            print_r('remote update', u)
        }

        const key = u['UserName']

        let person = people.get(key)

        if (person == undefined) {

            person = person_from_update(u)

            people.set(key, person)
            mark_new_person(person)

        } else {

            if (u["Pos"] != undefined && person.last != u["Last"]) {

                let new_pos = [ u["Pos"]["Lon"], u["Pos"]["Lat"] ]

                let track = new Object()
                track.pos = person.pos
                track.last = person.last
                track.marker = create_marker(track.pos)

                const len = person.track.push(track)
                if (len > track_depth) {
                    let tracked = person.track.shift()
                    people_layer.getSource().removeFeature(tracked.marker)
                    delete tracked.marker;
                }

                let p1 = getPointCoords(person.pos)
                let p2 = getPointCoords(new_pos)
                person.distance_tracked += get_length(p1, p2)

                person.pos = new_pos
                person.last = u["Last"]

                if (debug != 0) {
                    console.log("refreshed position for " + person.name)
                }
            }

            if (u["Status"] != undefined && person.Status != u["Status"]) {
                person.Status = u["Status"]
                if (debug != 0) {
                    console.log('refreshed status for ' + u['UserName'] + ": " + person.Status)
                }
            }
            if (u["MovingState"] != undefined && person.MovingState != u["MovingState"]) {
                person.MovingState = u["MovingState"]
                if (debug != 0) {
                    console.log('refreshed moving state for ' + u['UserName'] + ": " + person.MovingState)
                }

            }
        }
    }

    update_gui()
}

function init_html()
{
    let item

    item = document.getElementById('head_title');
    item.innerHTML = i18n['html_title']

    item = document.getElementById('thead_marker')
    item.title = i18n['html_clmarker_hint']
    item.innerHTML = i18n['html_clmarker_name']

    item = document.getElementById('thead_rank')
    item.title = i18n['html_rank_hint']
    item.innerHTML = i18n['html_rank_name']

    item = document.getElementById('thead_user')
    item.title = i18n['html_username_hint']
    item.innerHTML = i18n['html_username_name']

    item = document.getElementById('thead_status')
    item.title = i18n['html_status_hint']
    item.innerHTML = i18n['html_status_name']

    item = document.getElementById('thead_distance')
    item.title = i18n['html_distance_hint']
    item.innerHTML = i18n['html_distance_name']
}

/* start all js */
init_html()
init_map()
start_events()
